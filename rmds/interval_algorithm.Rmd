---
title: "Interval Optimisation Algorithm"
output:
  html_document: default
  html_notebook: default
  word_document: default
---
_An explanation of the processes used to minimise associated with the time_ 
_intervals used in the determination of AUC using trapezoidal integration_

# --------------------------------------------------------------------------------
``` {r sim.data, echo = F}
# Setup workspace  
  library(GA)
  library(ggplot2)
  theme_bw2 <- theme_set(theme_bw(base_size = 14))
  theme_update(plot.title = element_text(hjust = 0.5))
  
# Absorption Curve
  time.samp <- seq(0, 48, by = 2)
  absdata <- data.frame(
    time = time.samp,
    line1 = -0.2*time.samp + 4,
    line2 = -0.1*time.samp + 4
  )
  absdata$sumexp <- exp(absdata$line2) - exp(absdata$line1)
  #with(absdata, plot(time, sumexp))

# 2 Compartment Curve
  twodata <- data.frame(
    time = time.samp,
    line1 = -0.5*time.samp + 6,
    line2 = -0.05*time.samp + 5
  )
  twodata$sumexp <- exp(twodata$line1) + exp(twodata$line2)
  #with(twodata, plot(time, log(sumexp)))

# Create datasets
  err <- 1 + rnorm(n = length(time.samp), mean = 0, sd = 0.1)
  data1 <- data.frame(
    time = time.samp,
    conc = absdata$sumexp*err
  )
  err <- 1 + rnorm(n = length(time.samp), mean = 0, sd = 0.1)
  data2 <- data.frame(
    time = time.samp,
    conc = twodata$sumexp*err
  )
  
  plot.sumexp <- function(res, data) {
    plotdata <- data.frame(
      time = data$time,
      cobs = data$conc,
      pred = pred.sumexp(res[-length(res)], data$time, 0)
    )
    ylim <- c(0, 1.1*max(plotdata$cobs))
    xlim <- c(0, max(plotdata$time))

    plotobj <- NULL
    plotobj <- ggplot(data = plotdata)
    plotobj <- plotobj + ggtitle("Predicted and Observed vs. Time")
    plotobj <- plotobj + geom_point(aes(x = time, y = cobs))
    plotobj <- plotobj + geom_line(aes(x = time, y = pred), colour = "red")
    plotobj <- plotobj + scale_y_continuous("Concentration (mg/mL)\n", lim = ylim)
    plotobj <- plotobj + scale_x_continuous("\nTime after dose (hrs)", lim = xlim)
    plotobj
  }
```
### Trapezoidal Error
When approximating the definite integral (aka AUC) using trapezoidal 
integration, the number and spacing of time intervals directly impact the error
of this approximation. This error is represented by:
$$\epsilon=\int_a^{b}f(x)dx - \frac{b-a}{2}[f(a) + f(b)]$$
This can be simplified to:
$$\epsilon=\frac{(b-a)^3}{12}f''(\theta) \space \space \space \space{a \le \theta \le b}$$
This is achieved using integration by parts and the proof is in the link below.
Link: http://www.math.ucsd.edu/~ebender/20B/77_Trap.pdf 

Given a number of time intervals, it is possible to find the optimum spacing 
for these times to minimise the error associated with trapezoidal integration.

To optimise the time intervals, $f''(/theta)$ must be fixed. This requires a 
function describing the curve. A solution for this is the use of sum of 
exponentials.

### Why Sum of Exponentials?
Basic pharmacokinetic models are effectively described using the sum of one or
more exponential terms. For example a one-compartment pharmacokinetic model is 
described using:
$$C=C_0e^{-\frac{CL}{Vd}t}$$
If we let $-\frac{CL}{Vd}=m$ and $c=lny_0$ then this can be written more simply
as:
$$y=e^ce^{mx}$$
$$y=e^{mx+c}$$
This matches what is seen when viewing a one-compartment model using a 
log-scale for the y-axis.
``` {r 1comp.plot.example}
  examplesumexp.par <- list(CL = 10, Vd = 20, C0 = 100, time = 1:24)
  examplesumexp.par$concentration <- with(examplesumexp.par, C0*exp(-(CL/Vd)*time))
  with(examplesumexp.par, plot(time, log(concentration)))
```

By using $m$ and $c$ as parameters using the `optim` function the data can be
described using these equations.

### The Sum of Exponentials Algorithm
A key part of the algorithm is a function that can calculate the dependent
variable given a group of parameters. 

The function below is designed to take `x`, the parameters which describe the
sum of exponentials, `t` the time points to be predicted and `d` to calculate
the derivative (specifcally for determining the second derviative to determine
trapezoidal error).

``` {r pred.sumexp}
# Sum of exponentials predicted concentrations function
  pred.sumexp <- function(x, t, d = 0) {
  # Record whether there is an odd or even number of parameters
    l <- length(x)
    a <- ifelse(l %% 2 == 0, 0, 1)
  # Determine how many exponentials the parameters describe
    n <- ceiling(l/2)
  # Loop for number of exponentials
  # Add exponentials together as described by parameters
    for (i in 1:n) {
      if (i == 1) y <- x[i]^d*exp(x[i]*t + x[n+i])
      else if (i != n | a == 0) y <- y + x[i]^d*exp(x[i]*t + x[n+i])
    # If odd number of parameters (and last set of parameters) make absorption curve
      else if (a == 1) y <- y - x[i]^d*exp(x[i]*t)*sum(exp(x[(n+1):(2*n-1)]))
    }
    return(y)
  }
```

``` {r example.parameters, echo = F}
  list(
    bolus = c(slope1 = -0.5, slope2 = -0.05, int1 = 6, int2 = 5),
    absorp = c(slope1 = -0.1, slope2 = -0.2, int1 = 4)
  )
```

Parameters consist of two sets of numbers; the slope $m$ parameters and the
intercept $c$ parameters. It is important to note that $c$ is the 
log-transformed intercept, so when creating a sum of intercepts it must be 
transformed back. 

The number of $m$ parameters represent the number of exponentials in the sum.
The number of $c$ parameters contain the information required to determine 
whether the sum of exponentials is for predicting concentrations of an iv 
bolus curve or an absorption curve. An even number implies an iv bolus, an odd
number implies absorption. One less intercept is required for absorption, as 
the sum of the intercepts of the positive exponentials sum to the intercept of
the negative exponential.

The $d$ parameter (seen as a multiplier to the exponentials; $m^d$) simply 
determines the $d$th derivative for the sum of exponentials described by the
parameters. When $d$ these terms are equal to 1 and do not affect the 
exponentials

### Optimisation of Sum of Exponential Parameters
The first step of the algorithm is to determine the sum of exponentials that 
best describes the data. This function takes the `data` as input, a logical
statement of whether or not the data is for an `oral` drug and the maximum 
number of exponentials `nexp` that the function will try to optimise. 

``` {r mle.sumexp, echo = F}
# Maximum likelihood estimation function for parameter optimisation
  mle.sumexp <- function(par, x, y, ga = F) {
  # If using GA::ga set up for maximising of objective function value
    z <- ifelse(ga, 1, -1)
  # Determine exponential curve from given parameters
    yhat <- pred.sumexp(par[-length(par)], x)
  # Last parameter is equal to the sigma of density distribution
    sigma <- par[length(par)]
    loglik <- dnorm(y, yhat, abs(sigma), log = T)
    return(z*sum(loglik))
  }
```
``` {r optim.sumexp}
# Fit sum of exponentials to curve for different numbers of exponentials
  optim.sumexp <- function(data, oral = F, nexp = 3) {
  # Set up data for use, ready environment for loops
    x <- data[which(data[, 2] != 0), 1]
    y <- data[which(data[, 2] != 0), 2]
    opt.par <- list(NULL)
    opt.val <- list(NULL)
    opt.gra <- list(NULL)
    opt.con <- list(NULL)
    opt.mes <- list(NULL)
  # Determine fit by linear model for genetic algorithm boundaries
    lmres <- unname(lm(log(y) ~ x)$coefficients)
  # Begin loop
    for (i in 1:nexp) {
      if (i == 1 & !oral) {
      # Currently an area of issue around fitting 1 compartment curves
      # 1 compartment curve rarely (if ever) has the best obj
        sigres <- optim(
          0.1,
          function(z) mle.sumexp(unname(c(lmres[2], lmres[1], z)), x, y),
          method = "Brent", lower = 0.001, upper = 10^10
        )
        optres <- list(
          par = unname(c(lmres[2], lmres[1], sigres$par)),
          value = sigres$value,
          counts = NULL, convergence = 0, message = NULL
        )
      } else {
      # For all data being described by 2 or more exponentials
      # First use genetic algorithms to determine initial parameters
        gares <- ga("real-valued",
          mle.sumexp, x = x, y = y, ga = T,
          min = c(rep(lmres[2]*50, i + oral), rep(lmres[1]-2, i), 0.001),
          max = c(rep(lmres[2]/50, i + oral), rep(lmres[1]+2, i), 1),
          selection = gareal_lrSelection,
          crossover = gareal_spCrossover,
          mutation = gareal_raMutation,
          maxiter = 20,
          popSize = 250
        )
      # Then optimise the curve using standard hill-climbing optimisation
        optres <- optim(
          gares@solution,
          mle.sumexp,
          method = "BFGS",
          x = x, y = y
        )
      }
    # Collate the results
      opt.par[[i]] <- optres$par
      opt.val[[i]] <- optres$value
      opt.gra[[i]] <- optres$counts
      opt.con[[i]] <- optres$convergence
      opt.mes[[i]] <- ifelse(is.null(optres$message),
        "NULL", optres$message)
    }
  # name the results for output
    res <- list(par = opt.par, value = opt.val, counts = opt.gra,
      convergence = opt.con, message = opt.mes)
    res
  }
```

The `mle.sumexp` function seen in both the `ga` and `optim` functions is used 
for optimisation of parameters. It uses maximum likelihood estimation as shown
below. The parameters given to the function include the parameters used by 
`pred.sumexp` but also a value for sigma in the `dnorm` function.

``` {r mle.sumexp.echo}
  mle.sumexp
```

The biggest limitation with optimising the sum of exponential parameters is the
initial parameters that are used. A genetic algorithm is used to determine 
these parameters, as this results in initial parameters based on the objective 
value.

The use of genetic algorithms makes a few assumptions:
* The boundaries provided contain the parameters of best fit
    + current range of boundaries are 2500-fold, 50-fold and 1000-fold for 
    slope, intercept and sigma respectively
* The maximum iterations will allow the algorithm to reach an adequate set 
of initial parameters 
    + if initial parameters are not adequate, BFGS will not be able to 
    optimise the parameters
* The use of the GA package for convenience outweighs the loss of control by
not using my own genetic algorithm function

The `optim.sumexp` function produces the following output when used on oral drug data:

``` {r example.optim, echo = F}
  suppressWarnings(print(
    temp <- optim.sumexp(data2, oral = F)
  ))
```

`par` is the sum of exponential parameters

`value` is the objective function value from using mle

`counts` is the number of iterations of the function and gradient requred to
optimise

`convergence` is an error code of whether or not the convergence was successful

`message` gives information on the convergence

### Selecting the Number of Exponentials
Once the best parameters are determined for the sets of exponentials of 
interest, it is time to determine which sum of exponentials is best. As these
are effectively nested models, a chi-squared test has been chosen for model 
selection.

``` {r chisq.sumexp}
# Chi-squared difference test
# Takes a list of optim results and gives the best optim result
# i designates the best model
# j designates the model to compare to the best model
  chisq.sumexp <- function(opt) {
    i <- 1
    for (j in 2:length(opt$par)) {
      degf <- length(opt$par[[j]]) - length(opt$par[[i]])
      x <- opt$value[[i]] - opt$value[[j]]
      p <- pchisq(x, degf, lower.tail = F)
      if (p < 0.05) {
        i <- i + 1
      }
    }
    return(sapply(opt, function(x) x[i]))
  }
```

This gives the following result:
``` {r example.chisq, echo = F}
  print(
    temp2 <- chisq.sumexp(temp)
  )
  plot.sumexp(temp2$par, data2)
```

### Optimise Sampling Intervals
``` {r err.interv, echo = F}
  err.interv <- function(par, exp.par, tmin, tmax, theta) {
    times <- c(tmin, par, tmax)
    deltat <- diff(times)
    secd <- pred.sumexp(exp.par, theta, 2)  # d = 2 (second derivative)
    err <- abs(deltat^3*secd/12)
    sum(err)
  }
```

Using the exponential curve that best fits the data, the algorithm then 
determines the sampling intervals that will minimise  trapezoidal error when
used.

``` {r optim.interv}
# Interval optimising function
  optim.interv <- function(times, fit.par) {
  # Order the times and determine min and max times so they can be fixed
    x <- times[order(times)]
    init.par <- x[-c(1, length(x))]
    xmin <- min(x)
    xmax <- max(x)
    theta <- c(NULL)
  # Determine theta for each initial time, (time with maximum f''(x))
    for (i in 1:(length(times)-1)) {
      theta[i] <- optim(
        mean(c(times[i], times[i+1])),
        function(t, x) -abs(pred.sumexp(x, t, 2)),
        method = "L-BFGS-B", control = c(maxit = 500),
        lower = times[i], upper = times[i+1], x = fit.par
      )$par
    }
  # Determine optimal sampling intervals by minimising trapezoidal error
    res <- optim(
      init.par,
      err.interv,
      method = "L-BFGS-B", control = c(maxit = 500),
      lower = xmin, upper = xmax,
      exp.par = fit.par, tmin = xmin, tmax = xmax, theta = theta
    )
    return(res)
  }
```

The trapezoidal error is determined using the `err.interv` function below:

``` {r err.interv.echo}
  err.interv
```

There are a few issues with the implementation of this section:
* The value for theta only applies to the initial parameters
    + However you can't have an `optim` function within another `optim` function
    + This seems to place a large emphasis on the initial parameters
* Does not account for errors seen when using linear-up, log-down trapezoidal 
method
    + Theoretically weighs the "log-down" concentrations more heavily than it 
    should
    + Is this effect even important?
    
The result from using `optim.interv` can be seen below...
  
``` {r example.interv, echo = F}
  nobs <- 8
  tlast <- 24
  time.seq <- c(0, exp(seq(-4, 0, length.out = nobs))*tlast)
  print(temp3 <- optim.interv(time.seq, temp2$par))
```

Oh it doesn't even work now, that was unexpected...
